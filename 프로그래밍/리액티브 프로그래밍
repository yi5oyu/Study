리액티브 프로그래밍(Reactive Programming): 비동기 데이터 스트림과 변화의 전파를 중심으로 하는 프로그래밍 패러다임
 - 데이터가 변하면 자동으로 반응하여 시스템 전체가 일관된 상태를 유지하도록 함(데이터가 변경되면 그 변화가 의존하는 모든 부분에 자동으로 전파)

 명령형 프로그래밍: 어떻게 해야하는지
  - 순차적인 명령 실행
  - 상태 변화 직접 관리
  - 동기적 처리가 기본
 리액티브 프로그래밍: 무엇을 원하는지
  - 데이터 흐름과 변화에 반응
  - 상태 변화가 자동으로 전파
  - 비동기적 처리

 리액티브 매니페스토: 리액티브 시스템이 갖춰야 할 4가지 핵심 특성
  응답성(Responsive)
   - 시스템이 가능한 한 즉시 응답해야 함
   - 사용자에게 일관되고 예측 가능한 응답 시간 제공
   - 문제 발생 시에도 빠른 감지와 대응
  탄력성(Resilient)
   - 장애 상황에서도 응답성을 유지
   - 복제, 격리, 위임을 통한 장애 처리
   - 장애가 다른 구성 요소로 전파되지 않도록 격리
  유연성 (Elastic)
   - 작업 부하 변화에 따라 자원을 동적으로 할당
   - 확장과 축소가 자동으로 이루어짐
   - 병목 지점이 없는 설계
  메시지 주도 (Message Driven)
   - 구성 요소 간 비동기 메시지 전달
   - 느슨한 결합, 격리, 위치 투명성 확보
   - 백프레셔를 통한 부하 관리

주요 특징
 선언적 스타일: 개발자는 무엇을 원하는지만 명시, 어떻게 처리할지는 프레임워크가 담당
 비동기 처리: 콜백 지옥/Promise 체이닝 없이도 비동기 작업을 자연스럽게 조합할 수 있음
 변화의 전파: 데이터가 변경되면 자동으로 의존하는 모든 부분이 업데이트됨

구성요소
 데이터 스트림 (Data Stream): 시간에 따라 발생하는 데이터들의 연속적인 흐름
  - 연속성: 데이터가 끊임없이 흘러감
  - 시간성: 시간축을 가지고 순서대로 발생
  - 비동기성: 언제 데이터가 올지 예측할 수 없음
  - 무한성: 이론적으로 무한히 계속될 수 있음
 
 Observable: 데이터를 발행(emit)하는 객체(Observer들이 구독할 수 있는 데이터 소스)
  - 구독하기 전까지는 실행되지 않음(Lazy 실행)
  - 여러 값을 시간에 걸쳐 방출 가능
  - 완료되거나 에러로 종료될 수 있음
  - 취소 가능한 실행
  Cold Observable(Unicast 방식)
   - 구독할 때마다 새로운 데이터 스트림 생성
   - 각 구독자가 독립적인 데이터 받음
  Hot Observable(Multicast 방식)
   - 구독 여부와 관계없이 데이터 발행
   - 모든 구독자가 같은 데이터 스트림 공유

 Observer: 데이터를 구독(subscribe)하고 반응하는 객체
  - Observable이 방출하는 데이터를 받아서 처리하는 역할
  // 발행자-구독자 패턴
  observable.subscribe({
      next: value => console.log('받은 값:', value),
      error: err => console.error('에러:', err),
      complete: () => console.log('완료')
  });

 구독 관리(Subscription): Observable의 구독을 나타내는 객체
  - 구독을 취소하고 리소스를 해제하는 데 사용(메모리 누수 방지. 무한히 실행되는 스트림의 경우 구독 해제가 필요)

생명주기/이벤트 처리
 생명주기 메서드: Observer가 구독할 때 처리해야 하는 핵심 이벤트
  - onNext: 데이터 수신(스트림의 정상적인 데이터 흐름을 처리)
    Observable이 새로운 데이터를 방출할 때 호출되는 메서드
  - onError: 에러 처리(에러가 발생하면 스트림은 즉시 종료, 더 이상 데이터를 방출하지 않음)
    스트림에서 에러가 발생할 때 호출되는 메서드
  - onComplete: 스트림 완료(완료 후에는 더 이상 데이터가 방출되지 않음)
    Observable이 모든 데이터를 방출하고 정상적으로 종료될 때 호출되는 메서드

 Subject: Observer + Observable
  - Observable, Observer의 역할을 모두 수행할 수 있는 특별한 객체
  - 데이터를 구독할 수도 있고 동시에 데이터를 방출할 수도 있음
  - 데이터 중계 역할: 여러 Observable을 하나로 결합하거나, 하나의 Observable을 여러 구독자에게 전달하는 중계 역할을 수행
  // Subject의 종류
  Subject: 구독 시점 이후의 데이터만 받음
  BehaviorSubject: 현재 값을 저장, 새로운 구독자에게 즉시 전달(초기값 필요)
  AsyncSubject:완료될 때 마지막 값만 방출

백프레셔(Backpressure): 데이터 생산 속도가 소비 속도보다 빠를 때 발생하는 문제를 해결하는 메커니즘
 - 데이터 생산자와 소비자 간의 속도 차이 관리

Scheduler: Observable이 언제, 어떤 실행 컨텍스트에서 실행될지 제어하는 메커니즘
 - 작업 실행 시점 제어
 - 실행 컨텍스트 관리
 - 작업 우선순위 관리
 - 리소스 효율적 사용

함수형 연산자
 - 데이터 스트림을 변환, 필터링, 결합하는 데 사용
 - 복잡한 비동기 데이터 흐름을 간결하고 읽기 쉬운 코드로 표현할 수 있음
 map: 데이터 변환
  - 각 데이터를 다른 형태로 변환하는 연산자(1:1 변환)
 filter: 데이터 필터링
  - 조건을 만족하는 데이터만 통과시키는 연산자
 merge: 여러 스트림 결합
  - 여러 스트림을 하나로 합쳐서 동시에 구독하는 연산자
 debounce/throttle: 이벤트 제한
  - 과도한 이벤트 발생을 제어하여 성능을 최적화하는 연산자
  - debounce: 마지막 이벤트 후 일정 시간 대기
  - throttle: 일정 간격으로만 이벤트 허용
 distinctUntilChanged: 중복 제거
  - 연속된 중복 값을 제거하는 연산자
 switchMap/mergeMap: 스트림 변환
  - 내부 Observable을 생성하고 관리하는 변환 연산자
  - switchMap: 새로운 내부 스트림으로 교체(이전 구독 취소)
  - mergeMap(flatMap): 모든 내부 스트림 병합(동시 실행)
  - concatMap: 순차적 처리
  - exhaustMap: 진행 중인 작업이 있으면 무시
 combineLatest: 최신 값 결합
  - 여러 스트림의 최신 값을 결합하여 하나의 값으로 만는 연산자
