DB 인덱스(Index): 데이터 검색 성능을 향상시키기 위한 핵심적인 데이터 구조
 - 테이블의 특정 컬럼에 대한 별도의 정렬된 구조를 만들어, 데이터를 빠르게 찾을 수 있게 해주는 도구

 인덱스 없이 검색
  - 테이블의 모든 행을 순차적으로 검사(데이터가 많을수록 검색 시간이 선형적으로 증가)
 인덱스 검색
  - 인덱스는 정렬된 구조(주로 B-Tree)로 되어 있어 O(log n) 시간 복잡도로 빠른 검색

 종류
  클러스터드 인덱스(Clustered Index)
   - 테이블의 물리적 데이터 순서를 결정
   - 인덱스 자체가 데이터를 포함
   - 테이블당 하나만 존재 가능
   - Primary Key에 자동 생성
  비클러스터드 인덱스(Non-Clustered Index)
   - 별도의 구조로 존재하며 실제 데이터 위치를 가리킴
   - 테이블당 여러 개 생성 가능
   - 일반적으로 사용하는 인덱스
  복합 인덱스(Composite Index)
   - 여러 컬럼을 조합한 인덱스
   - 컬럼 순서가 중요함

 B-Tree(Balanced-Tree): 대용량 데이터를 효율적으로 저장하고 검색할 수 있도록 설계된 균형 트리(자가 균형 트리)
  - 모든 자녀 노드가 같은 레벨에 위치하며 트리의 높이를 최소화하여 검색 성능을 보장
  - 이진탐색트리(BST)를 일반화한 트리
  차수(Order)각 노드는 최대 (M-1)개의 키를 저장
   - M: 각 노드의 최대 자녀 노드 수
   - M-1: 각 노드의 최대 Key 수
   - ⌈M/2⌉: 각 노드의 최소 자녀 노드 수(3/2 = 1.5 => 2)(root, leaf 노트 제외)
   - ⌈M/2⌉ - 1: 각 노드의 최소 Key 수(root 노트 제외)
    * 올림 기호: ⌈ ⌉
            [10, 20] (키)
          /    |     \
        [5]   [15]    [25, 30] (10 보다 작은수 | 10과 20 사이수 | 20보다 큰 수)
       /  \   /  \    /   |   \
    [3] [7] [12][18] [23][27][35]
  검색
   - 루트 노드 > 노드 키 비교 > 자식 노드 이동 > 키 확인
  삽입
   - 삽입할 위치 리프 노드 찾음(여유 공간 있으면 삽입)
   - 여유 공간 없으면 좌우 key 분할하고 가운데 key 승격
  삭제
   - 삭제할 위치 리프 노트 찾음(제거)
   - 삭제 후 최소 key 수보다 적다면 재조정
