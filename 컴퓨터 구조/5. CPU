CPU마다 다름

ALU
 - 계산하는 장치
 - 레지스터로부터 `피연산자`를 받음 / 제어장치로부터 `제어신호`를 받음
  = 계산을 하기 위해 피연산자와 수행할 연산 필요
 - 결과값(숫자, 문자, 주소...)을 레지스터에 저장됨
 - 플래그를 플래그 레지스터에 저장됨
  = 플래그: 연산 결과에 대한 부가 정보(양/음수, 0, 오버플로우 등...)
   * 부호플래그, 제로플래그, 캐리플래그, 오버플로우플래그, 인터럽트플래그, 슈퍼바이저플래그
   
제어장치
 - 제어 신호를 발생시키고 명령어를 해석하는 장치
 - `클럭 신호` 받음
  = 클럭: 컴푸터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
 - 명령어 레지스터에서 `해석할 명령어` 받음
 - 플래그 레지스터에서 `플래그` 받음
 - 외부로 부터 `제어 신호` 받음
 - CPU 내부 전달
  = 레지스터(레지스터간 정보 교환, 행동 제어신호), ALU(수행할 연산)
 - CPU 외부 전달
  = 메모리(메모리 읽고 쓰기), 입출력장치(입출력장치 읽고 쓰고 테스트)
  
레지스터
 - CPU 내부에 있는 작은 임시저장장치(다양한 레지스터가 있고 각기 다른 역할을 가짐)
  1) 프로그램 카운터: 메모리에서 가져올 명령어의 주소(메모리에서 읽어 들일 명령어 주소)
  2) 명령어 레지스터: 해석할 명령어(방금 메모리에서 읽어 들인 명령어)
  3) 메모리 주소 레지스터: 메모리 주소 저장(주소 버스를 통해 읽고자 하는 주소가 거치는 레지스터)
  4) 메모리 버퍼 레지스터: 메모리와 주고 받을 값(데이터, 명령어)
    - 프로그램 카운터에 메모리의 주소 저장됨 > 메모리 주소 레지스터에 주소값 복사 
    -> 메모리 읽기 신호(제어 신호)를 제어 버스로 메모리 주소를 주소 버스로 메모리에 보냄 
    -> 해당 주소에 있는 메모리 정보를 데이터 버스로 메모리 버퍼 레지스터에 저장
    -> 프로그램 카운터 1증가됨(다음으로 실행될 주소, 실행 흐름을 바꾸는 명령어 실행 or 인터럽트 발생전 까진 순차적 실행)
    -> 메모리 버퍼 레지스터에로 가져온 데이터를 명령어 레지스터에 복사
  5) 플래그 레지스터: 연산 결과 or CPU 상태에 대한 부가적인 정보
  6) 범용 레지스터: 다양하고 일반적인 상황에서 자유롭게 사용
  7) 스택 포인터: 스택의 꼭대기를 가리키는 레지스터(스택 위치 표시)
  8) 베이스 레지스터: 오퍼랜드 필드 값과 특정 레지스터(베이스 레지스터 or 프로그램 카운터) 값을 더해 유효 주소 얻기(변위 주소 지정 방식)
     - 연산 코드 | 레지스터 | 오퍼랜드 => 레지스터 + 오퍼랜드 = 유효 주소
     - 상대 주소 지정 방식: 오퍼랜드 필드 값 + 프로그램 카운터 = 유효 주소 값
      = 오퍼랜드 필드 값이 +3이라면 현재 실행할 명령어(프로그램 카운터)로 부터 3번째 이후에 실행할 유효 주소를 알 수 있음(오퍼랜드 필드 값이 변위 값이 됨)
     - 베이스 레지스터 주소 지정 방식: 오퍼랜드 필드 값 + 베이스 레지스터 값 = 유효 주소 값
      = 오퍼랜드 필드 값이 50이라면 기준 주소(베이스 레지스터)로부터 50번지 떨어진 명령어 실행

명령어 사이클
 - 일정한 주기가 반복되어 프로그램 속 명령어 실행됨
 - 인출 사이클: 메모리로 부터 데이터를 CPU로 가져옴
 - 실행 사이클: CPU에서 실행
 - 간접 사이클: 메모리 접근이 더 필요한 경우 간접 사이클 실행 후 실행 사이클 실행

인터럽트
 - 동기 인터럽트(예외): CPU가 예기치 못한 상황을 접했을 때 발생(예외적인 상황을 먼저 처리)
 - 비동기 인터럽트(하드웨어 인터럽트): 입출력 장치(키보드, 마우스, 프린터...)에 의해 발생
  = 입출력 장치는 CPU에 비해 느리기 때문에 하드웨어 인터럽트가 없다면 주기적으로 입출력 장치를 확인해야함
 - 인터럽트 처리 순서
  1) 입출력장치가 CPU에 인터럽트 요청 신호 보냄
   * 인터럽트 요청 신호
  2) CPU는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 인터럽트 여부 확인
  3) 인터럽트 요청이 있을시 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 확인
   * 인터럽트 플래그: 플래그 레지스터안에 인터럽트 플래그 확인(하드웨어 고장, 정전 등은 인터럽트 플래그로 막을 수 없음(non maskable interrupt))
  4) 인터럽트를 받아들일 수 있으면 CPU는 지금까지의 작업을 백업
   * 백업: 스택영역에 레지스터(프로그램 카운터, 메모리 주소 레지스터, 메모리 버퍼 레지스터, 명령어 레지스터)의 값들을 저장 후 프로그램 카운터에 인터럽트 서비스 루틴이 있는 주소를 저장
  5) CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴 실행
   * 인터럽트 서비스 루틴: 인터럽트가 발생했을 때 해당 인터럽트를 처리하는 프로그램(메모리에 저장되어 있음)
   * 인터럽트 벡터: 각각의 인터럽트를 구분하기 위한 정보
  6) 인터럽트 서비스 루틴 실행 끝나면 백업해 둔 작업을 복구하여 실행 재개
   
CPU 속도
 - 클럭
  : 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위(CPU는 명령어 사이클에 맞춰 명령어 실행)
   = 일반적으로 클럭 속도(Hz)와 CPU속도는 비례함, 클럭이 높아지면 발열이 심해짐
   = 2.5GHz(2.5*10^9): 1초에 클럭이 25억번 반복
 - 코어
  : 명령어를 실행하는 부품(하나의 코어는 ALU, 제어장치, 레지스터를 가지고 있음)
   = 코어 수에 따라 싱글코어(1), 듀얼코어(2), 트리플코어(3), 쿼드코어(4), 헥사코어(6)...(2개 이상의 코어는 멀티 코어)
   = CPU 속도는 코어 수에 반드시 비례하지 않음
 - 스레드
  : 실행 흐름의 단위
   = 하드웨어적 스레드: 하나의 코어가 동시에 처리하는 명령어 단위(논리 프로세서)
    - 레지스터 세트가 여러개 있으면 여러 명령어를 동시에 처리할 수 있음
     * 논리 프로세서: 논리적인 CPU의 개수, 메모리가 느끼는 작업 흐름 개수(메모리 입장에서 CPU의 코어의 개수 모름)
    ex) 하나의 코어가 하나를 처리(1코어 1스레드 CPU), 하나의 코어가 두개를 동시에 처리(2코어 4스레드 CPU)(멀티스레드 프로세서(CPU))
   = 스프트웨어적 스레드: 하나의 프로그램에서 독립적으로 실행되는 단위
    - 싱글스레드, 멀티스레드(하나의 프로그램에서 동시에 두개의 영역이 실행됨)
    ex) 입력받은 내용을 화면에 보여주는 기능, 맞춤법 검사하는 기능, 입력 내용을 수시로 저장하는 기능(스레드를 3개 만들어서 각각 실행되게 만듬)
        1코어 1스레드 CPU도 여러 스프트웨어적 스레드를 만들 수 있음(매우 빠르게 실행되기 때문에 마치 동시에 실행되는 것처럼 보임)
 - 명령어 병렬 처리
  = 명령어 파이프라인: 같은 단계가 겹치지 않으면 CPU는 각 단계를 동시에 실행할 수 있음
   - 명령어가 처리되는 과정을 비슷한 시간 간격으로 나눔
   1) 명령어 인출
   2) 명령어 해석
   3) 명령어 실행
   4) 결과 저장
    ex) 하나의 명령어는 인출 > 해석 > 실행 > 저장, 다른 명령어는 첫번째 명령어가 해석하는 동안 명령어 실행할 수 있음(같은 명령어 처리가 아니라면 병렬 처리 가능)
  = 파이프라인 위험: 명령어 파이프라인이 성능 향상에 실패하는 경우
   - 데이터 위험: 명령어 간의 의존성때문에 발생(이전 명령어를 끝까지 실행해야하는 실행하는 경우)
    ex) 명령어 1: R1 <- R2 + R3 / 명령어 2: R4 <- R1 + R5 (명령어 2는 R1에 의존하기 때문에 명령어 1이 끝나야 실행할 수 있음)
   - 제어 위험: 프로그램 카운터의 갑작스러운 변화(점프, 인터럽트...)
    ex) 점프로 인해 다른 분기(주소)로 넘어가면 병렬로 실행 중이던 다른 명령어는 완전히 실행되지 못함
    * 분기 예측: 프로그램 다음 분기를 예측하는 기술
   - 구조 위험: 서로 다른 명령어가 같은 CPU 부품(ALU, 레지스터)를 쓰려고 할 때 발생
  = 슈퍼스칼라: CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조(멀티스레드 프로세서)
   - 파이프라인 개수에 비례해 처리 속도 증가(파이프라인 위험도 증가로 인해 반드시 비례하진 않음)
  = 비순차적 명령어 처리
   - 파이프라인 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 명령어 병렬 처리 기법
    ex) 의존성 없는 명령의 순서 바꿈(전체 프로그램 실행 흐름에 영향없음)
 - 명령어 집합(구조)(ISA)
  = 명령어의 생김새, 연산, 주소 지정은 CPU마다 다름(명령어 해석 방식, 레지스터 종류/개수, 파이프라이닝 용이성... 등 다 달라짐)
  = CPU가 이해할 수 있는 명령어 모음(CPU 언어)
   * 같은 소스코드가 CPU에 따라 다른 저급언어로 컴파일됨
  = 하드웨어가 스프트웨어를 어떻게 이해할지에 대한 약속
  = CISC(Complex Instruction Set Computer)(시스크)
   : 복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
    ex) x86, x86-64
   - 복잡하고 다양한 명령어 활용(명령어 형태와 크기가 다양한 가변 길어 명령어)
   - 상대적으로 적은 수의 명령어로도 프로그램 실행 가능
   - 명령어 파이프라이닝 불리(명령어 크기/실행되기까지 시간이 일정하지 않음, 복잡한 명령어 때문에 명령어하나 실행하는데 여러 클럭 주기 필요)
   - 복잡한 명령어 사용 빈도 낮음
  = RISC(Reduced Instructuib Set Computer)(리스크)
  : 단순하고 적은 수의 고정 길이 명령어 집합 활용(명령어 종류 적고 짧고 규격화된 명령어 사용)
   ex) ARM
  - 메모리 접근 최소화(load, store) 레지스터 적극 활용
  - 명령어 종류가 적어 더 많은 명령어로 프로그램 동작시킴

----------------------------------------------------------------------------------------------------------------------------------------------------
              CISC              |              RISC
      복잡하고 다양한 명령어      |       단순하고 적은 명령어
         가변 길이 명령어         |        고정 길이 명령어
      다양한 주소 지정 방식       |       적은 주소 지정 방식
  프로그램 이루는 명령어 수가 적음 | 프로그램을 이루는 명령어 수가 많음
    여러 클럭에 거쳐 명령어 수행  |      1클럭 내외로 명령어 수행
     파이프라이닝하기 어려움      |      파이프라이닝하기 쉬움
