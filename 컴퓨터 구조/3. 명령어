명령어: 연산 코드와 오퍼랜드로 구성
 - 연산 코드: 수행할 연산
  = CPU마다 연산코드 종류/개수 다양함
   1) 데이터 전송
    - MOVE: 데이터를 옮겨라
    - STORE: 메모리에 저장 
    - LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라
    - PUSH: 스택에 데이터 저장
    - POP: 스택의 최상단 데이터 가져와라
   2) 산술/논리 연산
    - ADD / SUBTRACT / MULTIPLY / DIVIDE: + / - / * / % 수행
    - INCREMENT / DECREMENT: 오퍼랜드에 1 더하기 / 1 빼기
    - AND / OR / NOT: AND / OR / NOT 연산 수행
    - COMPARE: 두 개의 숫자 or TRUE / FALSE 값 비교
   3) 제어 흐름 변경
    - JUMP: 특정 주소로 실행 순서 옮겨라
     ex) JUMP 120: 120번지에 있는 명렁어 실행
    - CONDITIONAL JUMP: 조건에 부합할때 특정 주소로 실행 순서를 옮겨라
    - HALT: 프로그램 실행 멈춰라
    - CALL: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
    - RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라
   4) 입출력 제어
    - READ(INPUT): 특정 입출력 장치로부터 데이터를 읽어라
    - WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라
    - START IO: 입출력 장치를 시작하라
    - TEST IO: 입출력 장치의 상태를 확인하라
 - 오퍼랜드: 연산에 사용될 데이터 or 연산에 사용될 데이터가 저장된 위치(주소 필드)
  ex) 어셈블리어에서 오퍼랜드
      연산코드  오퍼랜드
        mov     eax, 0   (오퍼랜드 두개)
        pop     rbp      (오퍼랜드 한개)
        ret              (오프랜드 없음)
 - 명령어 주소 지정 방식(addressing modes)
  : 연산에 사용할 데이터가 저장된 위치를 찾는 방법(유효 주소를 찾는 방법)
  : 명령어 내에서 표현할 수 있는 데이터 크기가 제한되어 있음
   = 데이터의 위치를 오퍼랜드에 명시하면 명시된 주소에서는 데이터를 온전히 사용할 공간이 생김(연산코드와 오퍼랜드를 결합한 형태보다 더 큰 공간 활용 가능)
  : 유효 주소(effective address)
   = 연산에 사용할 데이터가 저장된 위치
  * 즉시 주소 지정 방식(immediate addressing mode)
   - 연산에 사용할 데이터를 오퍼랜드 필드에 명시(빠르지만 연산에 사용할 데이터 크기가 연산 코드만큼 작아질수 있음)
  * 직접 주소 지정 방식(direct addressing mode)
   - 오퍼랜드 필드에 유효 주소 명시(유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듦)
  * 간접 주소 지정 방식(indirect addressing mode)
   - 유효 주소의 주소를 명시(메모리에 유효 주소를 명시)
   - 유효 주소를 크게 가져갈 수 있지만 여러번 주소를 찾아야함으로 속도가 느림
  * 레지스터 주소 지정 방식(register addressing mode)
   - 연산에 사용할 데이터가 저장된 레지스터 명시(메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠름(레지스터는 CPU안에 있음, 직접 주소 지정 방식보다 빠를 수 있음))
