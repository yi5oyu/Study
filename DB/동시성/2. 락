락(Lock): 동시에 여러 트랜잭션이 같은 데이터에 접근할 때 데이터 무결성을 보장하기 위한 메커니즘

 - 공유 락(Shared Lock, S-Lock): 읽기 전용
   > 여러 트랜잭션이 동시에 가질 수 있음
   > 공유 락이 걸린 데이터는 수정할 수 없음
 - 배타 락(Exclusive Lock, X-Lock): 읽기/쓰기 독점
   > 오직 하나의 트랜잭션만 가질 수 있음
   > 다른 트랜잭션은 읽기도 쓰기도 불가능

 범위
  - 행 레벨 락(Row-Level Lock)
   > 특정 행에만 락을 걸음
   > 가장 세밀한 제어, 동시성이 높음
   > 락 오버헤드가 가장 큼
  - 페이지 레벨 락(Page-Level Lock)
   > 데이터 페이지 단위로 락을 걸음
   > 행 레벨과 테이블 레벨의 중간
   > SQL Server에서 주로 사용
  - 테이블 레벨 락(Table-Level Lock)
   > 전체 테이블에 락을 걸음
   > 가장 단순하지만 동시성이 낮음
   > 대량 작업 시 효율적

 락 획득/해제
  - 암시적 락(Implicit Locking): 대부분의 SQL 문에서 자동으로 락이 걸림
  - 명시적 락(Explicit Locking): 개발자가 직접 락을 제어

 락 에스컬레이션(Lock Escalation)
  - 시스템이 많은 행 락을 더 큰 범위의 락으로 자동 변환하는 과정
   ) 행 락이 일정 이상이 되면 테이블 락으로 변환
   ) 페이지 락이 전체 테이블의 40% 이상이 되면 테이블 락으로 변환

데드락(Deadlock): 두 개 이상의 트랜잭션이 서로가 가진 락(자원)을 기다리며 무한 대기 상태에 빠지는 현상
 - 서로 상대방이 가진 것을 원하지만, 자신이 가진 것을 놓지 않아서 영원히 기다리게 되는 상황

 4가지 조건이 모두 만족될 때 발생
  1. 상호 배제(Mutual Exclusion): 한 번에 하나의 트랜잭션만 자원을 사용할 수 있음
  2. 점유 대기(Hold and Wait): 자원을 가진 상태에서 다른 자원을 기다림
  3. 비선점(No Preemption): 다른 트랜잭션이 가진 락을 강제로 빼앗을 수 없음
  4. 순환 대기(Circular Wait): 트랜잭션들이 원형으로 서로를 기다림(A → B → C → A)

해결 방법
 - 데드락 감지 및 해결(Detection & Resolution): 대부분 DBMS가 자동으로 처리
 - 타임아웃 설정

방지 방법
 - 락 순서 일관성 유지
 - 트랜잭션 크기 최소화
 - 낮은 격리 수준 사용(주의 깊게 사용해야함)
 - 명시적 락 순서 제어
 - 레코드 존재 여부 미리 확인
