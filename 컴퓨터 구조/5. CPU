CPU마다 다름

ALU
 - 계산하는 장치
 - 레지스터로부터 `피연산자`를 받음 / 제어장치로부터 `제어신호`를 받음
  = 계산을 하기 위해 피연산자와 수행할 연산 필요
 - 결과값(숫자, 문자, 주소...)을 레지스터에 저장됨
 - 플래그를 플래그 레지스터에 저장됨
  = 플래그: 연산 결과에 대한 부가 정보(양/음수, 0, 오버플로우 등...)
   * 부호플래그, 제로플래그, 캐리플래그, 오버플로우플래그, 인터럽트플래그, 슈퍼바이저플래그
   
제어장치
 - 제어 신호를 발생시키고 명령어를 해석하는 장치
 - `클럭 신호` 받음
  = 클럭: 컴푸터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
 - 명령어 레지스터에서 `해석할 명령어` 받음
 - 플래그 레지스터에서 `플래그` 받음
 - 외부로 부터 `제어 신호` 받음
 - CPU 내부 전달
  = 레지스터(레지스터간 정보 교환, 행동 제어신호), ALU(수행할 연산)
 - CPU 외부 전달
  = 메모리(메모리 읽고 쓰기), 입출력장치(입출력장치 읽고 쓰고 테스트)
  
레지스터
 - CPU 내부에 있는 작은 임시저장장치(다양한 레지스터가 있고 각기 다른 역할을 가짐)
  1) 프로그램 카운터: 메모리에서 가져올 명령어의 주소(메모리에서 읽어 들일 명령어 주소)
  2) 명령어 레지스터: 해석할 명령어(방금 메모리에서 읽어 들인 명령어)
  3) 메모리 주소 레지스터: 메모리 주소 저장(주소 버스를 통해 읽고자 하는 주소가 거치는 레지스터)
  4) 메모리 버퍼 레지스터: 메모리와 주고 받을 값(데이터, 명령어)
    - 프로그램 카운터에 메모리의 주소 저장됨 > 메모리 주소 레지스터에 주소값 복사 
    -> 메모리 읽기 신호(제어 신호)를 제어 버스로 메모리 주소를 주소 버스로 메모리에 보냄 
    -> 해당 주소에 있는 메모리 정보를 데이터 버스로 메모리 버퍼 레지스터에 저장
    -> 프로그램 카운터 1증가됨(다음으로 실행될 주소, 실행 흐름을 바꾸는 명령어 실행 or 인터럽트 발생전 까진 순차적 실행)
    -> 메모리 버퍼 레지스터에로 가져온 데이터를 명령어 레지스터에 복사
  5) 플래그 레지스터: 연산 결과 or CPU 상태에 대한 부가적인 정보
  6) 범용 레지스터: 다양하고 일반적인 상황에서 자유롭게 사용
  7) 스택 포인터: 스택의 꼭대기를 가리키는 레지스터(스택 위치 표시)
  8) 베이스 레지스터: 오퍼랜드 필드 값과 특정 레지스터(베이스 레지스터 or 프로그램 카운터) 값을 더해 유효 주소 얻기(변위 주소 지정 방식)
     - 연산 코드 | 레지스터 | 오퍼랜드 => 레지스터 + 오퍼랜드 = 유효 주소
     - 상대 주소 지정 방식: 오퍼랜드 필드 값 + 프로그램 카운터 = 유효 주소 값
      = 오퍼랜드 필드 값이 +3이라면 현재 실행할 명령어(프로그램 카운터)로 부터 3번째 이후에 실행할 유효 주소를 알 수 있음(오퍼랜드 필드 값이 변위 값이 됨)
     - 베이스 레지스터 주소 지정 방식: 오퍼랜드 필드 값 + 베이스 레지스터 값 = 유효 주소 값
      = 오퍼랜드 필드 값이 50이라면 기준 주소(베이스 레지스터)로부터 50번지 떨어진 명령어 실행

명령어 사이클
 - 일정한 주기가 반복되어 프로그램 속 명령어 실행됨
 - 인출 사이클: 메모리로 부터 데이터를 CPU로 가져옴
 - 실행 사이클: CPU에서 실행
 - 간접 사이클: 메모리 접근이 더 필요한 경우 간접 사이클 실행 후 실행 사이클 실행

인터럽트
 - 동기 인터럽트(예외): CPU가 예기치 못한 상황을 접했을 때 발생(예외적인 상황을 먼저 처리)
 - 비동기 인터럽트(하드웨어 인터럽트): 입출력 장치(키보드, 마우스, 프린터...)에 의해 발생
  = 입출력 장치는 CPU에 비해 느리기 때문에 하드웨어 인터럽트가 없다면 주기적으로 입출력 장치를 확인해야함
 - 인터럽트 처리 순서
  1) 입출력장치가 CPU에 인터럽트 요청 신호 보냄
   * 인터럽트 요청 신호
  2) CPU는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 인터럽트 여부 확인
  3) 인터럽트 요청이 있을시 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 확인
   * 인터럽트 플래그: 플래그 레지스터안에 인터럽트 플래그 확인(하드웨어 고장, 정전 등은 인터럽트 플래그로 막을 수 없음(non maskable interrupt))
  4) 인터럽트를 받아들일 수 있으면 CPU는 지금까지의 작업을 백업
   * 백업: 스택영역에 레지스터(프로그램 카운터, 메모리 주소 레지스터, 메모리 버퍼 레지스터, 명령어 레지스터)의 값들을 저장 후 프로그램 카운터에 인터럽트 서비스 루틴이 있는 주소를 저장
  5) CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴 실행
   * 인터럽트 서비스 루틴: 인터럽트가 발생했을 때 해당 인터럽트를 처리하는 프로그램(메모리에 저장되어 있음)
   * 인터럽트 벡터: 각각의 인터럽트를 구분하기 위한 정보
  6) 인터럽트 서비스 루틴 실행 끝나면 백업해 둔 작업을 복구하여 실행 재개
   
CPU 속도
 - 클럭 속도(Hz)
