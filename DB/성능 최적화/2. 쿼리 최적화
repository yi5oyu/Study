N+1 쿼리 문제: 1번의 메인 쿼리 + N번의 추가 쿼리
 - JOIN 사용: 1번의 쿼리로 모든 데이터 한 번에 가져오기
 - IN 절 사용: 한번에 조회
 - 서브쿼리 활용: 한 번에 계산

SELECT: 필요한 것만 가져와야함
 - 필요한 컬럼만 명시
 - 요약 정보만(일부 정보)
 - 계산은 어플리케이션에서 해야함

WHERE: 인덱스에 적합하게 사용
 - 함수 대신 범위 조건 사용(함수 사용하면 인덱스 사용 못함)
 - 칼럼에 연산하지 말고 조건값 미리 계산
   WHERE amount * 1.1 > 110000; -> WHERE amount > 100000;(110000 / 1.1 = 100000)
 - 뒤 와일드카드, 전체 문자열 매칭 사용(앞 와일드카드(%검색어) 사용하면 인덱스 사용 못함)

JOIN: 
 - INNER JOIN: 양쪽에 모두 있는 데이터(더 빠름) 
 - LEFT JOIN: 왼쪽 테이블의 모든 데이터 + 매칭되는 오른쪽 데이터(더 포괄적)
 - EXISTS: 존재 여부만 확인
 - 사전 필터링으로 JOIN 대상 줄이기

서브쿼리
 - 상관 서브쿼리 문제: 외부 테이블의 각 행마다 서브쿼리가 실행되어 매우 느림
   1. JOIN + GROUP BY로 변환하여 한 번의 테이블 스캔으로 처리
   2. EXISTS vs IN 적절히 선택 (결과 크기에 따라)
   3. 비상관 서브쿼리는 성능상 문제없음

COUNT 
 - COUNT 함수의 성능 차이
   COUNT(*): 가장 빠름, COUNT(1): COUNT(*)와 동일
   COUNT(컬럼): NULL 값 제외하므로 약간 느림
 - 조건부 COUNT
   한 번의 스캔으로 모든 결과 계산

LIMIT과 페이징 최적화
 - OFFSET 기반 페이징 문제: 페이지가 뒤로 갈수록 선형적으로 느려짐
   OFFSET 500000 → 500,010개 행 처리 후 10개만 반환
 - 커서 기반 페이징: WHERE id > 마지막ID ORDER BY id LIMIT 10
   모든 페이지에서 일정한 성능 (O(log n))
 - 정렬 컬럼에 인덱스 필수

UNION 
 - UNION vs UNION ALL
   UNION: 중복 제거 과정 필요(느림)
   UNION ALL: 중복 허용(빠름)
 - 중복이 없다면 UNION ALL 사용
 - UNION을 JOIN으로 변환 고려
 - 조건을 OR절로 통합 검토
